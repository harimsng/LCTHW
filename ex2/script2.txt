(ominous guitar riff) - [Narrator] Hello and welcome to exercise two. In this exercise we're gonna learn about a concept that might be a little foreign when coming from a more modern language. The makefile. The makefile is an old school tool. I mean it's pretty much how you made software up until more recent scripting languages. So the plan for this exercise is I'm gonna show you some simple Make usage. You saw me use the tool a little bit in exercise one. I'm gonna show you how to set a few important settings, and then I'm gonna show you how to break a makefile so that's easy. So what do I mean by makefile, how does it work? Okay, so the thing to remember about makefiles is it's implied dependencies and ancient lore. That's how they work. Okay? So. I'm in exercise two. Let me just (mumbles). Make sure, yup I am. And I have this file here. It's called, Makefile. And I can show you also in the directory I'm using from the lectures. The thing about this makefile is notice I haven't really described any source code in here. Okay. Now the thing that I need, when I ran that last make from ex1, let me just copy the ex1.c code here so I can work with it. When I did make ex1, it just sorta figured it out. That's the weird thing about Make. Sort of it's magic to people. They don't get it, they don't understand like, "Well how can it possibly work?" I mean how does it know that when I say, "Make me an ex1," it figures out, "Okay I can take ex1.c, and run this command, "and output that." That's where the ancient lore comes from. Make has built into it a bunch of rules, it's a rules engine that says, "Given a target by a name, "look for any number of similar files "with the name but maybe a different extension, "and when you find the file with an extension "you know how to build, Make," as if I'm talking to Make, "Then this is the command to run." That's it. Deep in the bowels of Make, or, you know, possibly in the configuration file, or something like that, is a specifier that says, "When told to build an output target "of ex1, or any file, "and you find a .c file, "run this command." The makefile is basically a way to manually specify these configurations, these dependencies. So that's where the second part, or the first part, implied dependencies. We're saying, "Ex1 on the command line "depends on ex1.c, "and ex1.c can be turned into this, "resolving the dependency with this command." It's a rules engine. If you're not familiar what a rules engine is look 'em up. They're very handy. So, let's say I run some C commands. Just to start off, I have this up here, this -Wall. But I can also just do this, I can go like this. I can give Make options on the command line. Oh, sorry. That's one way to do it. Do it one more time. Now, the makefiles options override mine on the command line in this example I have here. But if I were delete this, let's do this one more time, again. There we go. Notice the option that I gave here is -Wall? Now if I just do make ex1, like that. One more time. See, it removes the options, and I do this. Okay, so that's your first clue. You can use Make as a way to set options in the same way that I got these command line options. Okay? So, implied dependencies. The command that Make knows about for building things knows about, also, this setting called CFLAGS, this environment variable. And I can set this in the makefile. The next thing, see how I have this clean here? Well if I do make clean, it seems to run this command here. Again, that's a dependency. I'm saying, "When given the target clean, "you do this." So that means I can do a few things. I can do something like this. I can create a target called all, and then I can say I have certain dependencies. So I can list them all. So I can actually do something like this. I can do all depends on clean, and depends on ex1 to be resolved. When I run this, what Make is gonna do is it's gonna go, "If I say make all, it's going to do clean, "which is this one, "jump down here, do that, "and then do ex1," just like I had done it on the command line. So let's do it. Notice it did rm -f ex, and there we go. However, there's another implied, a lot of this is implied so you save typing. There's no point in me telling Make make all all the time. If you just have Make, Make knows, usually by default, I just wanna run the first target I run into. And that's it. I could also do commands here. So now when I run it, see how it prints out "Extra stuff?" Well, if I could spell extra. So I can depend on other commands. Those commands get run by Make, or those targets, I can depend on other targets. Those targets get run in my Make, and then Make comes back and will run my command. However, I didn't explicitly mention ex1. There's no ex1 in this file as a target. I didn't do this. I didn't go ex1 depends on ex1.c. I didn't do that. That's the implied dependencies part in ancient lore. There's ancient lore from, you know, decades of how to build C files. So I don't have to tell Make everything. Make already knows how to build C files. I just have to say one of my targets is exercise one. That's it. We will get much more into this as we go through. (stammers) We'll just really use makefiles later in the book, but for now this is all you really need to know. Just remember it's the dependencies and ancient lore. So there's the makefile we did. Setting the options we already did. Now, the extra credit. I sort of already just showed you how to do that first one. We're gonna create an all target that say ex1. Now the way I did it I threw clean in. I wouldn't do that, I would do this. So then you just do make. You don't have to do for all. You wanna force a build you do clean. And there you go. Let's look at the next extra credit. Read man make so you can see all the options and everything. Man make. Depending on the version of Make you have, BSD has a different kind of Make than Linux, which uses GNU Make. Apple uses GENie Make, or it uses their own weird Make, which is totally different but it's the same concept. You'll also wanna do man cc, that's the C compiler. It's gonna have loads of options and everything. It would be good to go through these options and see if you can set strange options using this CFLAGS setting. Remember the CFLAGS setting is just something Make understands to know what it should pass as CFLAGS. You know, flags to the C compiler. Research makefiles online, just remember makefiles are a little, um, yeah. It's hard to get really good information about how to write good makefiles. There's a few books that are really old. It sorta works the same but I think modern Make, the GNU webpage for their Make is good, the BSD Make manual is good so read that. Go through another makefile for another C project or any other project. I would just go on GitHub, look for a C project that you saw, see what their makefile looks like. Some projects don't even use Make. They use other things. So check that out. That's the end of lecture two.

