(electric guitar music) - [Zed] Hello. Welcome to Learn C the Hard Way, and thank you for buying my book. Actually, it's not even a book. It's a course. It's a whole course. These videos are a big part of the book, and the point of the videos is to show you things that require more interaction. For example, if I wanna show you how to break some software, the videos are where it's at. And the majority of the time is gonna be in the videos. Now, the point of this course is to take someone who's a early programmer, not a beginner, not someone who's just starting out, but an early programmer. You have two programming languages that you should know already pretty okay, and you're wanting to get from someone who's just getting into computer science topics and learn all the major computer science topics. That's this book. Plus, other computational topics, like security, testing, things like that. I'm also adding in algorithms, a little bit of network programming. Just about everything is in this book. It also teaches C, but the C is almost... It's almost a plot device in the whole grander scheme of teaching you more computational computer science subjects. The plan for this first exercise is to get you to write your first C program, to build it, and then break it. I'm gonna break it. I'm gonna show you how to build it, but I'm not gonna type all the code in in every single video. That's pointless. You should already know how to type code in. I shouldn't be having to show you how to type code in. You should be learning that on your own. If you don't know how to do that, go read another book. I prefer my two books, Learn Python the Hard Way and Learn Ruby the Hard Way for people who are total beginners. Start there. Now, in order for you to do this exercise and all the exercises, you have to type code in. However, there's a small problem. Typing C code in can be error-prone. I'm gonna show you ways to type it in that will help you learn, but you need a way to check your work. It's also good to have the lecture notes from these videos. So, with that in mind, I have a GitHub repository, and in this GitHub repository is every exercise and also the lecture notes. So, this means you can check this repository out, you can see the code I have, and you can compare it to yours. I'm gonna show you how to do that in this exercise, but I'm gonna warn you there's no point in buying my book and going through this whole course if you're just gonna cheat yourself and use my code. You gotta struggle with the code and getting your code right and only as a last ditch effort check your code against my code, okay? Part of the whole problem with programming is figuring out whether you wrote something correctly or not and why it's broken. So, how do you get this? The first thing is I'm in my terminal here, and you have to know how to use Git, so I've got Git installed. If you don't know how to use Git, look online. It's one of the more popular tools right now. It's really good to know how to use it. Now, the next thing you have is this is the repository URL, and this is what I'm gonna clone. To show you that in the presentation, here it is in the presentation, and this, you can actually look. That file there is actually what's being presented here, so these match up. That means as I make updates to this GitHub repository, you'll get the updates, and it's almost like I'm updating the video. So, to get the code, make sure you're in your directory, and you're gonna do git clone and the URL. Now, where I got that URL, if you don't have access to the repository itself, this URL here comes from the GitHub repository over here. So, H-T-T-P clone URL. You can also, if you log in, you have a GitHub account, you can use the SSH version. Totally fine. This is a public repository, and all the code in it should be MIT licensed, and the lecture notes are copyrighted by me, but you should be able to use all the code for whatever you want. Now, once you have that, I'm gonna run this really quick so you can see that it works, and it works fairly quickly, and inside that is all of the exercises. So, we're in exercise one, and that's where that is, and there's ex1. The next thing is you have to type this code in. I'm gonna type the code in. I'm gonna show you how I check it after I... how you can check it if you're super stuck and you can't make it work. Remember, you gotta try and make it work. Maybe set a timer, like you'll try for an hour. Then you'll go cheat. So, first, I'm gonna show you how to do it right. The first thing you have to do, and I'm actually in a different directory, I just did that as example, but to make the videos a little nicer in the directory display, I'm doing that. So, I'm in this directory. And also, it's good for me to have a separate check-out. Now, I'm in exercise one, and you should have a separate directory where you have each of these exercises. Don't use my directory. Use my directory as a reference tool. Okay, once you have that, (typing) I'm in this directory, and I'm gonna make a file called ex1_zed.c. You just make one called ex1.c because I'm just showing you a demo right now. But you should be making this in a separate directory. Now, the first mistake most beginners make is they do this with the code. So let me just... I'll just use this code. I'll just do this real quick. All right? So, that's the code. Now, what most beginners do is they do this. They pull this off to the side here, and they go like that because remembering this stuff is really difficult. The problem is is the whole point is to get better at remembering this stuff. It helps you to remember things if you actually have to hold it in your head and then copy it over. It's almost like a mini-flashcard if you don't do what I'm doing here. See how I don't have to remember things for as long? That means you're sort of cheating yourself out of a learning opportunity, so it's better if you do this, full screen for both of these windows, your text editor and also your code. Now, your code would be in the PDF for the book. That's primarily what you're gonna be doing is you got the PDF, you copy it out of the PDF. And also, remember, if there's an error in the PDF, come grab the lecture code. Maybe I fixed it in lecture code. And if I didn't, tell me how to fix it. So, what you want to do instead is this, this flipping back and forth. Now, the reason why is it acts like a flashcard. I'm typing the code, and I have to look at the code here, remember it, and then type it. (typing) Now, I've been typing C code for long time, and for me, this is simple. I also wrote this. Now, let's say you're doing this, and you go, "Um, um, okay. Uh." See, you'll be flipping back and forth, and so, you'll have to be int main, and you do that. Int argc, and you might be doing a lot of flipping at first, but then eventually, as you go, you're gonna start figuring this out, and you're gonna be able to type longer and longer lines of code as you work, just like I'm doing. (typing) And there we go. Now, one thing that you gotta remember is when you type this code in, you wanna be as exactly the same as mine as possible. You're training your attention to detail, which is something that everyone needs to train a lot. So, how do you check your work? I have this file here, and what you can use is a tool called diff. So, if we do this, diff, here's mine from Learn C the Hard Way lectures, and here's the one you typed. Now, if you had the lectures checked out in a different directory, you just do the path to that, and then do the path to your file, and when you go like that, if there's differences, it will show you them. So, I'm gonna go add a difference just so you can see that real quick. Let's say, for whatever reason, no, a better error would be to forget this. So, you forgot that. Now, my text editor is telling me. It says down here that I have an error. See the red marks? Now, when I do diff, it shows, this left-hand arrow over here says, "Oh, ex1.c is different. It has that line. Your file has this other line." There you go. You know your differences. You should be able to make the file you have typed in exactly the same as mine so that when you run diff like that, it's pristine. It's exactly the same. This solves the problem of you type all the code in and it doesn't work, and then you go, "Oh, well, Zed's exercise must be broken." Most likely, your code is broken. There's a higher probability of that, and that's a good attitude to have. Now, I don't assume my code is perfect at all. But, you have to sort of assume yours is broken until proven otherwise. The first check is does yours diff from mine. Make it exactly the same as mine. Then, go run it, and see if it's still broken, and then, contact me about it. So, I've done that. Now my code is written, and the thing that we gotta do is make it build. So, I'm gonna go in and build it. I'm gonna do this one. So, in the book, I talk about how you do that. And it'll build it. We get in more complex ways to do it, but if you just type make ex1_zed, it'll build it. The other method is to just do, see this line right here that it did? Just do that. (typing) And it's the same thing. All this is saying is use the C compiler to compile this zed.c file, and put the output in ex1. If you wanna find out what options you have, you do man cc. I'm on a Mac, so I'm using a compiler named clang. You might be using gcc. It totally depends. Once I do that, I can then run it, and it prints out the results. Pretty simple. Now, let's look at this code real quick. The main thing, and it would be good for you to read the description I have in the exercise in the PDF, this exercise is to get you to type code. You might not have any idea what's going on, but if you've got two programming languages, you kinda know. This is bringing in some kind of library named standard io is what I would call it, stdio. Then, this is the main function. I could tell you what this is. It's a comment. This is some kind of variable because I use it over here. Then, maybe you don't know what these ints mean. Printf, print function. And then return. Now, if you're used to a language like Python, you don't have to have a main function. You don't have to explicit return values. It's a little different beast. You also don't have to compile it, really. So, struggle with this, and try to figure out what these parts do. Read the PDF. Make sure you understand what it is. One other key trick, if you don't know what each thing is, write a comment above it. Assign 100 to the distance integer. Just like that. That will teach you to closely analyze code. So, let's break this. The videos are gonna be more breaking or improving when we get towards the end of the book. Breaking, learning to break your own code, is a key component to making good, solid code. You should assume your code is broken always. There's always a probability it can be broken. So, get it there, and break it. Don't be heartbroken if your code is busted. It's fine. It's just code. It's not any reflection of you as a horrible person. So, how can we break this? So, this code is so simple. It's difficult to really do anything to break it. Instead, I'm gonna show you some common errors that people make. So, for example, that one that I just did. You have a %d format here. You'll learn more about these later, but these are similar to Python's format strings. They're things that you should have already encountered, and that says, "Hey, I'm gonna give printf an integer of some kind to translate." So, that means printf is gonna try and read it, but what happens in C? In Python, you just get an error, right? I think in Ruby, you might get just a blank, so what do you get there? So, let's do it. So, I got a warning, which is great. It's great to have warnings on these. Always try to solve all of your warnings. Just consider all of your warnings errors. Always solve all of them. So, it still ran it, and just to make sure, I'm gonna get rid of this. I'm gonna rebuild this. All right. Now, when I run ex.1 zed, what happens? So, it says more conversions than data arguments. That means I don't have enough arguments. I get this crazy number. Well, why is that? The main reason why is because printf and C operates on raw, straight memory. There's no fancy fantasy world between you and the computer. The computer is harsh reality right there. When you do Python or Java or Ruby, you have a fake computer, kind of a virtual machine that protects you from mistakes like this. In C, you don't have any protection at all. The OS gives you protection from crashing other programs and keeps things pretty safe, but for the most part, C just lets you go all over the place. So, when you told printf to read an integer, it literally tried to read an integer, and then what happened is, and we'll get into more of this later, it basically found junk where it thought there would be a parameter. It's looking at its parameters that it got. We like to say, for example, argc, argv are parameters. Printf is expecting a parameter, and rather than go, "Oh, there isn't one," it can't tell. It just assumes, "Well, whatever is at that space in memory, that's the parameter." And in our case, it's a piece of junk. This is your first sort of rule with C code. Any time you see something weird, it's a bug in memory. It's a memory error. It's a pointer. It's a missing parameter. It's always a memory error when you just see junk, weird stuff, things just running weirdly. It's almost always, always a memory error. Pointers getting put in the wrong places, pointers not being freed, reusing things that have been freed, that's your first sort of like, if it's weird, it's memory. At the end of the exercise, and remember, you gotta read the book because that's where the majority of the information is for you to tackle, and it's good to learn to be able to read and type code because that's the vast majority of programming. There's some extra credit. So, the first one, open the ex1 file in your text editor and change or delete random parts. So, let's try that out. So, in my case, this is the file. That's actually the binary that got created. So, let's grab some random stuff. I don't even know if I can do this. I think there's a binary mode, but I'm just gonna sort of be lazy. There we go. All right. That, who knows what that's going to do? Let's run it again. There we go. It just crashed. Now, next thing we can do, check this out. We can run this little program, oh, I believe on... Uh-huh, there we go. (typing) Oh, I gotta do a password real quick. Yep, and then, it ran again. So, what happened here? Well, I took the binary that was created by the compiler, and I just removed random chunks of it. So, of course, it's gonna crash. But, there's interesting things. It crashed in a sort of strange spot. I could go investigate why it crashed. I could debug it like that. It's interesting to try and do stuff like that. The next one, you want to print out five more lines of text, something more complex than this little hello, world. You want to run the man 3 printf, so let's do man 3 printf. That's how you do it. Those are man pages. Those are really useful when you're doing UNIX coding. For each line, write out the symbols you don't understand, and see if you can guess what they mean. So, what I mean by symbols is what does int mean? You should know what parentheses are. What does the asterisk mean? What does this bracket mean? What does include, pound, printf, return? What are these things? Go look them up. You'd be surprised how just making a guess, just make a guess what you think return does. It probably does return like it does in other programming languages. Then you go look it up. Yeah, pretty much, that's what it does. That's the end of lecture one. Remember, go through the exercise. This stuff will mostly work the same on Linux. You might just use ddb. Also, I talk about how you can run this on Windows. For the most part, it should work the same. If you're using Cygwin, it will work the same. Just deal with it. Struggle with it. But one thing, if you're on Windows, it might be good to just install Linux in a VM and try it out. I mean, the whole world is going Linux. A lot of, even Microsoft is supporting Linux on its zero platform, so might be the future to go check it out. Get familiar with it. Save yourself some trouble down the road when you need to use it, anyway. Next exercise is gonna be exercise two. It's gonna be shorter because I don't need to go through all of this stuff. I don't need to go through every single piece. I'm gonna load code. I'm gonna break it. I'm gonna talk about some key points. I'm gonna go through the extra credit, and then, we'll move on quicker. All right, thank you very much.
